#!/usr/bin/env bash

# Source $1 if it exists.
source_if() {
  [ -e "$1" ] && . "$1"
}

# Check if a command is on the PATH.
installed() {
  command -v "$1" >/dev/null 2>&1
}

# Join all arguments except $1. $1 is the delimiter.
join() {
  local IFS="$1"
  shift
  echo "$*"
}

# Split all arguments except $1. $1 is the delimiter.
split() {
  local IFS="$1"
  shift
  printf "%s\n" $@
}

# Print the given arguments, filtering out duplicates.
uniquify() {
  printf "%s\n" "$@" | awk '!x[$0]++'
}

# Add all arguments to a path environment variable except $1. $1 is the name of
# the variable. The delimiter is assumed to be ":", like in $PATH and friends.
add_to_path() {
  local var paths old_paths
  var="$1"
  shift
  old_paths=($(split ":" "${!var}"))
  paths=$(join ":" $(uniquify "$@" "${old_paths[@]}"))
  printf -v "${var}" "${paths[@]}"
  export ${var}
}

# Prompt user to confirm
prompt_confirm() {
  local p="$* [y/N]:"
  local confirm
  while true; do
    read -p "echo $p " confirm
    case $confirm in
    [yY]*) return 0 ;;
    [nN]*) return 1 ;;
    esac
  done
}
