#!/usr/bin/env python3

"""

Generate random passwords. Mainly useful for copying and pasting
into password managers

"""

import argparse, random, string, sys, unicodedata, re, pickle, os
from collections import Counter, defaultdict
from pprint import pprint

rg = random.SystemRandom()

pw_dir = os.path.dirname(os.path.realpath(__file__))

regex_lowercase = '[{:s}]'.format(''.join(string.ascii_lowercase))
regex_uppercase = '[{:s}]'.format(''.join(string.ascii_uppercase))
regex_digits = '[{:s}]'.format(''.join(string.digits))
regex_special = '[{:s}]'.format(re.escape(''.join(string.punctuation)))

def _unicode_character_generator():
  """Generates unicode characters
  """
  # Arbitrarily chosen unicode character categories:
  # Ll = Letter, lower case (Latin, Greek, etc)
  # Lo = Letter, other (Chinese, Japanese, etc)
  # Lu = Letter, upper case (Latin, Greek, etc)
  # Nd = Number, decimal digit (Arabic, Bengali, etc)
  # Pd = Punctuation, dash
  # Pc = Punctuation, close
  # Pf = Punctuation, Final quote (may behave like Ps or Pe depending on usage)
  # Pi = Punctuation, Initial quote (may behave like Ps or Pe depending on usage)
  # Po = Punctuation, Other
  # Ps = Punctuation, Open
  # Sc = Symbol, Currency
  # Sk = Symbol, Modifier
  # Sm = Symbol, Math
  # Zs = Separator, Space

  UNICODE_CATEGORIES = [ 'Ll', 'Lo', 'Lu', 'Nd', 'Pd', 'Pc', 'Pf', 'Pi', 'Po',
                         'Ps', 'Sc', 'Sm' ]

  for i in range(sys.maxunicode):
    c = chr(i)
    if c.isprintable() and unicodedata.category(c) in UNICODE_CATEGORIES:
      yield(c)

def random_password(opts):
  return(''.join(rg.sample(opts.alphabet,opts.length)))

def words_from_file(filename):
  words = []
  with open(filename, encoding="utf-8") as f:
    for word in f.readlines():
      words += word.rsplit()
  return(words)

def build_markov_chain(filename):
  """Read words from a file and build a Markov chain.
  """
  counts = defaultdict(Counter)
  for word in words_from_file(filename):
    prev = None
    for c in word:
      counts[prev][c] += 1
      prev = c
  return(counts)

def markov_password(m, opts):
  word = ""
  prev = None
  for _ in range(opts.length):
    if not m[prev]: prev = None
    prev = rg.choices(list(m[prev].keys()), list(m[prev].values()))[0]
    word += prev
  return(word)

def add_password_requirement(pw, alphabet, regex, n):
  if n > 0:
    # Get positions of matches of regex in pw
    matches = [m.start() for m in re.finditer(regex, pw)]
    # We need to replace this many characters to meet the requirement
    k = max(n - len(matches), 0)
    # Make a list of fields to change (must be in positions which are NOT
    # matches for regex)
    change = rg.sample(set(range(len(pw))) - set(matches), k)
    # Make the replacements
    for i in change:
      pw = pw[:i] + rg.choice(alphabet) + pw[i+1:]
  return(pw)

def add_password_requirements(pw, opts):
  pw = add_password_requirement(pw, string.ascii_lowercase, regex_lowercase, opts.minimum_lower)
  pw = add_password_requirement(pw, string.ascii_uppercase, regex_uppercase, opts.minimum_upper)
  pw = add_password_requirement(pw, string.digits, regex_digits, opts.minimum_digits)
  pw = add_password_requirement(pw, string.punctuation, regex_special, opts.minimum_special)
  return(pw)

def main():
  
  """
  Process command line arguments and do things accordingly
  """
  
  parser = argparse.ArgumentParser(description='Generate random passwords')
  parser.add_argument("length", nargs='?', type=int, default=16,
                      help="length of password")
  parser.add_argument("--number", "-n", type=int, default=1,
                      help="number of passwords to generate")
  parser.add_argument("--pronounceable", "-p", default=False, action="store_true",
                      help="Create human pronounceable passwords")
  parser.add_argument("--lower", "-l", default=False, action="store_true",
                      help="Use lower case letters")
  parser.add_argument("--minimum-lower", "-L", type=int, default=0,
                      help="minimum number of lowercase characters required")
  parser.add_argument("--upper", "-u", default=False, action="store_true",
                      help="Use upper case letters")
  parser.add_argument("--minimum-upper", "-U", type=int, default=0,
                      help="minimum number of upper characters required")
  parser.add_argument("--digits", "-d", default=False, action="store_true",
                      help="Use digits")
  parser.add_argument("--minimum-digits", "-D", type=int, default=0,
                      help="minimum number of digit characters required")
  parser.add_argument("--special", "-s", default=False, action="store_true",
                      help="Use special characters (punctuation)")
  parser.add_argument("--minimum-special", "-S", type=int, default=0,
                      help="minimum number of special characters required")
  parser.add_argument("--characters", "-c", default='',
                      help="Specify individual characters")
  parser.add_argument("--unicode", "-z", default=False, action="store_true",
                      help="Use a large unicode character set")
  parser.add_argument("--build-markov", "-b", action="store",
                      help="Build a markov chain with the specified source and destination files")
  opts = parser.parse_args()

  if opts.build_markov:
    # Build the markov chain and write to file
    with open(pw_dir + "/pw.data","wb") as f:
      pickle.dump(build_markov_chain(opts.build_markov), f)
  elif opts.pronounceable:
    # Make pronounceable passwords
    with open(pw_dir + "/pw.data", "rb") as f:
      markov_data = pickle.load(f)
      for _ in range(opts.number):
        print(add_password_requirements(markov_password(markov_data, opts), opts))
  else:
    # Make completely random passwords
    if any([opts.lower, opts.upper, opts.digits, opts.special, opts.characters]):
      # use only specified character sets
      opts.alphabet = ''
      if opts.lower: opts.alphabet += string.ascii_lowercase
      if opts.upper: opts.alphabet += string.ascii_uppercase
      if opts.digits: opts.alphabet += string.digits
      if opts.special: opts.alphabet += string.punctuation
      opts.alphabet += opts.characters
    elif opts.unicode:
      opts.alphabet = ''.join([c for c in _unicode_character_generator()])
    else:
      # no specific character sets were specified so use the defaults
      opts.alphabet = string.digits + string.ascii_letters + string.punctuation

    for _ in range(opts.number):
      print(add_password_requirements(random_password(opts), opts))

if __name__ == '__main__':
    main()
