#!/usr/bin/env bash
# Status line style prompt

# Just calculate this once to reduce calls to external programs
[ -z "$__bash_prompt_hostname" ] && __bash_prompt_hostname=$(hostname -s) && export __bash_prompt_hostname

upsearch () {
  local directory="$PWD"
  while [ -n "$directory" ]; do
    if [ -e "$directory/$1" ]; then
      printf "$directory/$1"
      return 0
    fi
    directory=${directory%/*}
  done
  return 1
}

directory_helper () {
  printf ${PWD/$HOME/"~"}
}

git_helper () {
  # detect .git directory
  # print current branch; add an asterisk if there are uncommitted changes
  local gitdir && gitdir=$(upsearch .git) || return 1
  local gitdir=${gitdir%/*}
  local githead && githead=$(cat "$gitdir/.git/HEAD") || return 1
  githead=${githead##*/}
  local gitfiles; gitfiles=$(git -C "$gitdir" ls-files --exclude-standard --others)
  printf "$githead"
  [ -n "$gitfiles" ] || printf "*"
}

virtualenv_helper () {
  [ -n "$VIRTUAL_ENV" ] || return 1
  printf ${VIRTUAL_ENV##*/}
}

node_helper () {
  # detect package.json
  # print "name" field
  local package && package="$(upsearch package.json)" || return 1
  local re='\"name\": \"([^\"]*)'
  [[ $(cat "$package") =~ $re ]] || return 1
  printf "${BASH_REMATCH[1]}"
}

vagrant_helper () {
  # detect Vagrantfile
  # print .vagrant/machines/$machine_name
  local vagrantfile && vagrantfile="$(upsearch Vagrantfile)" || return 1
  local vagrantdir="${vagrantfile%/*}/.vagrant/machines"
  for f in $vagrantdir/*; do printf "${f##*/}"; done
}

clojure_helper () {
  # detect project.clj or build.boot
  # print ...
  if local bootfile && bootfile="$(upsearch build.boot)"; then
    local re=":project +'([^ ]+)"
    [[ $(cat "$bootfile") =~ $re ]] && printf "${BASH_REMATCH[1]}"
  elif local projectfile && projectfile="$(upsearch project.clj)"; then
    local re="\(defproject +([^ )]+)"
    [[ $(cat "$projectfile") =~ $re ]] && printf "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

jobs_helper () {
  local job_count; job_count="$(jobs | awk 'END {print NR}')"
  [[ $job_count -gt 0 ]] || return 1
  printf $job_count "job"
  [[ $job_count -gt 1 ]] && printf "s" # make jobs plural
  return 0
}

tmux_helper () {
  [[ -z "$TMUX" ]] || return 1
  local sessions; sessions="$(tmux ls 2>/dev/null)" || return 1
  local session_count; session_count="$(echo "$sessions" | awk 'END{print NR}')"
  [[ $session_count -gt 0 ]] && printf "tmux:" $session_count
}

datetime_helper () {
  date +"%Y-%m-%d %r"
}

do_str () {
  for (( c=0; c<$2; c++)) ; do
    printf "%s" "$1"
  done
}

re_replace () {
  local new=$1
  local re="(.*)$2(.*)"
  while [[ $new =~ $re ]]; do
    printf .
    new=${BASH_REMATCH[1]}${3}${BASH_REMATCH[2]}
  done
  echo "$new"
}

# Print with specified colors
with_color () {
  # background
  printf "\e[48;5;${1}m"
  # foreground
  printf "\e[38;5;${2}m"
  echo -e -n "${3}"
  # reset
  printf "\e[0m"
}

# http://www.fvue.nl/wiki/Bash:_Passing_variables_by_reference
if_append () {
  local s; s="$(eval $2)" || return 1
  local p; p=$(printf "$3" "$s")
  eval $1+=\"\$p\"
}

bash_prompt () {
  local last_status=$?

  local left=
  [ $last_status = 0 ] || left=$(with_color 125 255 " $last_status ")
  # Only display username and hostname if this is an ssh session
  if [ -n "$SSH_CLIENT" ]; then
    left+=$(with_color 003 000 " $USER ")
    left+=$(with_color 002 000 " $__bash_prompt_hostname ")
  fi
  if_append left git_helper         "$(with_color 005 000 ' %s ')"
  if_append left virtualenv_helper  "$(with_color 028 255 ' %s ')"
  if_append left node_helper        "$(with_color 023 255 ' %s ')"
  if_append left clojure_helper     "$(with_color 024 255 ' %s ')"
  if_append left vagrant_helper     "$(with_color 095 255 ' %s ')"
  if_append left directory_helper   "$(with_color 006 016 ' %s ')"

  local right=
  if_append right jobs_helper       "$(with_color 055 007 ' %s ')"
  if_append right tmux_helper       "$(with_color 038 000 ' %s ')"
  if_append right datetime_helper   "$(with_color 240 255 ' %s ')"

  # Strip out invisible characters before counting to get actual display width
  # local raw_line=$(re_replace "$left$right" "\e[^m]+m" "")
  # local raw_line; raw_line="${left//\\/}${right//\\/}"
  local raw_line; raw_line=$(echo "$left$right" | perl -pe 's/\x1b\[[^m]+m//g')
  local length=${#raw_line}
  local columns; columns=$(tput cols)
  local padding=$(($columns - $length)) && [[ $padding -lt 0 ]] && padding=0
  printf "\r%s%s%s\n" "$left" "$(with_color 236 236 "$(do_str " " $padding)")" "$right"
}

PS1=$(with_color 000 255 "\$ ") && export PS1

PROMPT_COMMAND='bash_prompt' && export PROMPT_COMMAND
