#!/usr/bin/env bash
# Status line style prompt

# Just calculate this once to reduce calls to external programs
[ -n "$__bash_prompt_hostname" ] || export __bash_prompt_hostname=$(hostname -s)

upsearch () {
  local directory="$PWD"
  while [ -n "$directory" ]; do
    if [ -e "$directory/$1" ]; then
      echo -e -n "$directory/$1"
      return 0
    fi
    directory=${directory%/*}
  done
  return 1
}

directory_helper () {
  echo -e -n ${PWD/$HOME/"~"}
}

git_helper () {
  # detect .git directory
  # print current branch; add an asterisk if there are uncommitted changes
  local gitdir && gitdir=$(upsearch .git) || return 1
  local gitdir=${gitdir%/*}
  local githead && githead=$(cat "$gitdir/.git/HEAD") || return 1
  githead=${githead##*/}
  local gitfiles=$(git -C "$gitdir" ls-files --exclude-standard --others)
  echo -e -n "$githead"
  [ -n "$gitfiles" ] || echo -e -n "*"
}

virtualenv_helper () {
  [ -n "$VIRTUAL_ENV" ] || return 1
  echo -e -n ${VIRTUAL_ENV##*/}
}

node_helper () {
  # detect package.json
  # print "name" field
  local package && package="$(upsearch package.json)" || return 1
  local re='\"name\": \"([^\"]*)'
  [[ $(cat "$package") =~ $re ]] || return 1
  echo -e -n "${BASH_REMATCH[1]}"
}

vagrant_helper () {
  # detect Vagrantfile
  # print .vagrant/machines/$machine_name
  local vagrantfile && vagrantfile="$(upsearch Vagrantfile)" || return 1
  local vagrantdir="${vagrantfile%/*}/.vagrant/machines"
  for f in $vagrantdir/*; do echo -e -n "${f##*/}"; done
}

clojure_helper () {
  # detect project.clj or build.boot
  # print ...
  if local bootfile && bootfile="$(upsearch build.boot)"; then
    local re=":project +'([^ ]+)"
    [[ $(cat "$bootfile") =~ $re ]] && echo -e -n "${BASH_REMATCH[1]}"
  elif local projectfile && projectfile="$(upsearch project.clj)"; then
    local re="\(defproject +([^ )]+)"
    [[ $(cat "$projectfile") =~ $re ]] && echo -e -n "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

jobs_helper () {
  local job_count="$(jobs | awk 'END {print NR}')"
  [[ $job_count -gt 0 ]] || return 1
  echo -e -n $job_count "job"
  [[ $job_count -gt 1 ]] && echo -e -n "s" # make jobs plural
  return 0
}

tmux_helper () {
  tmux ls >/dev/null &2>1 && return 1
  [[ "$TERM" = "screen" ]] && return 1
  local session_count="$(tmux ls 2>/dev/null | wc -l | awk '{ print $1; }')"
  [[ $session_count -gt 0 ]] && echo -e -n "tmux: " $session_count
  return 0
}

datetime_helper () {
  date +"%Y-%m-%d %r"
}

with_color () {
  # background
  echo -e -n "\e[48;5;${1}m"
  # foreground
  echo -e -n "\e[38;5;${2}m"
  echo -e -n "${3}"
  # reset
  echo -e -n "\e[0m"
}

do_str () {
  for (( c=0; c<$2; c++)) ; do
    printf "%s" "$1"
  done
}

re_replace () {
  local new=$1
  local re="(.*)$2(.*)"
  while [[ $new =~ $re ]]; do
    echo -e -n .
    new=${BASH_REMATCH[1]}${3}${BASH_REMATCH[2]}
  done
  echo "$new"
}

# http://www.fvue.nl/wiki/Bash:_Passing_variables_by_reference
if_append () {
  local s && s="$(eval $2)" || return 1
  local p && p=$(printf "$3" "$s")
  eval $1+=\"\$p\"
}

bash_prompt () {
  local last_status=$?

  local left=
  [ $last_status = 0 ] || left=$(with_color 125 255 " $last_status ")
  # Only display username and hostname if this is an ssh session
  if [ -n "$SSH_CLIENT" ]; then
    left+=$(with_color 003 000 " $USER ")
    left+=$(with_color 002 000 " $__bash_prompt_hostname")
  fi
  if_append left git_helper         "$(with_color 005 000 ' %s ')"
  if_append left virtualenv_helper  "$(with_color 028 255 ' %s ')"
  if_append left node_helper        "$(with_color 023 255 ' %s ')"
  if_append left clojure_helper     "$(with_color 024 255 ' %s ')"
  if_append left vagrant_helper     "$(with_color 095 255 ' %s ')"
  if_append left directory_helper   "$(with_color 006 016 ' %s ')"

  local right=
  if_append right jobs_helper       "$(with_color 055 007 ' %s ')"
  if_append right tmux_helper       "$(with_color 038 000 ' %s ')"
  if_append right datetime_helper   "$(with_color 240 255 ' %s ')"

  # Strip out invisible characters before counting to get actual display width
  # local raw_line=$(re_replace "$left$right" "\e[^m]+m" "")
  local raw_line=$(echo "$left$right" | perl -pe 's/\x1b\[[^m]+m//g')
  local length=${#raw_line}
  local COLUMNS=$(tput cols)
  local padding=$(($COLUMNS - $length))
  [[ $padding -lt 0 ]] && padding=0
  printf "\r%s%s%s\n" "$left" $(with_color 236 236 $(do_str "_" $padding)) "$right"
}

export PS1=$(with_color 000 255 "\$ ")

export PROMPT_COMMAND='bash_prompt'
