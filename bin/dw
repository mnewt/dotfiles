#!/bin/sh
#
# dw: Docker wrapper
# Shell system for building and managing docker containers

scriptname="dw"
scriptbuildnum="0.5"
scriptbuilddate="2016-05-19"

### TODO
# Add iptables config to firewall function

### VARS

WHITE="\033[1;37m"
CYAN="\033[1;36m"
GREEN="\033[1;32m"
NO_COLOR="\033[0m"

### FUNCTIONS

display_ver () {
  echo "$scriptname version $scriptbuildnum - $scriptbuilddate"
}

help () {
  display_ver   # Print script-title, build-number, and build-date
  cat <<-'EOF'
Shell system for building and managing docker containers
Run each function in succession
USAGE: $scriptname [BUILD-DIR | BUILD-FILE] [function1] [function2] [...]
  No arguments: dw build create start
EOF

  exit 0
}

exe () {
  # Display and execute the command
  >&2 echo "\$ $@"; "$@"
}

first () {
  # Get the first argument
  echo "$@" | cut -d ' ' -f1
}

rest () {
  echo "$@" | cut -s -d ' ' -f2-
}

contains () {
  case "$2" in
    *"$1"*)
      return 0 ;;
    *)
      return 1 ;;
  esac
}

startswith () {
  # Does $2 start with $1?
  case $2 in
    $1*)
      return 0 ;;
    *)
      return 1 ;;
  esac
}

timeago () {
  # Print how long it has been since the date specified
  # $1: start time
  old=$(date -d "${1}" +%s)
  new=$(date +%s)
  ((t=${new}-${old}))
  ((y=${t}/31556952))
  ((mo=(${t}%31556952)/2592000))
  ((d=(${t}%2592000)/86400))
  ((h=(${t}%86400)/3600))
  ((m=(${t}%3600)/60))
  ((s=${t}%60))

  if [ $y -gt 0 ]; then
    printf "%d year" $y
    [ "$y" == "1" ] || echo -n "s"
  elif [ $mo -gt 0 ]; then
    echo -n "$mo month"
    [ "$mo" == "1" ] || echo -n "s"
  elif [ $d -gt 0 ]; then
    printf "%d day" $d
    [ "$d" == "1" ] || echo -n "s"
  elif [ $h -gt 0 ]; then
    printf "%d hour" $h
    [ "$h" == "1" ] || echo -n "s"
  elif [ $m -gt 0 ]; then
    printf "%d minute" $m
    [ "$m" == "1" ] || echo -n "s"
  else
    printf "%d seconds" $s
  fi
  echo " ago"
}

isrunning () {
  # This seems like a better way, but it does unexpected things sometimes
  # $(docker inspect -f '{{.State.Running}}' $name 2>/dev/null)
  docker ps | grep -q $name
}

containerexists () {
  docker ps -a  | grep -q $name
}

buildpre () {
  # Run before build
  :
}

buildpost () {
  # Run after build
  :
}

rebuild () {
  # Build the container
  buildpre
  if [ -f "$build_dir/Dockerfile" ]; then
    exe docker build "$@" -t $name $build_dir
    if [ "$nettype" == "pipework" ]; then
      exe wget "https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework" \
        -O "$build_dir/pipework"
      exe chmod u+x "$build_dir/pipework"
    fi
  else
    exe docker pull $image
  fi
  buildpost
}

build () {
  # Build the container wtih caching disabled
  clean
  rebuild --no-cache
}

publishports () {
  # Write out docker publish options
  [ -n "$localip" ] && ip_opts="$(echo $localip | cut -d '/' -f1):"
  case $ports in
    -*)
      echo -n $ports
      ;;
    *:*)
      for p in $ports; do
        echo -n "-p $ip_opts$p "
      done
      ;;
    *)
      for p in $ports; do
        echo -n "-p $ip_opts$(echo -n $p | cut -d "/" -f1):$p "
      done
      ;;
    esac
}

createnetwork () {
  # Create the docker network and output `docker create` network options
  case $nettype in
    pipework)
      # pipework will set up the network
      echo -n "--net none"
      ;;
    bridge)
      docker network inspect $network 2>&1 >/dev/null || \
        exe docker network create $subnet_opts $network >/dev/null
      echo -n "--net $network "
      publishports
      ;;
  esac
}

create () {
  # Create the container
  remove
  [ -z "$(docker images -q $name)" ] && build
  exe docker create $volumes $options $(createnetwork) -h $name --name $name "$image"
}

startpost () {
  # Setup after starting container
  if [ "$nettype" == "pipework" ]; then
    # Wait until container is started
    while ! isrunning $name; do
      sleep 1
    done
    # Add IP address to host adapter using pipework
    [ "$nettype" == "pipework" ] && \
      exe "$build_dir/pipework" $adapter $name "$localip"
  fi
  firewall
}

stoppost () {
  # Tear down after stopping container
  :
}

start () {
  # Start the container
  containerexists $name || create
  [ "$nettype" == "bridge" ] && \
    [ -n "$localip" ] && \
    ! ip address show | grep -q "$localip" && \
      exe ip address add "$localip" dev $adapter
  if [ contains "-a" "$*" ]; then
    # Start the container, attach STDOUT/STDERR and forward signals
    exe exec docker start "$@" $name
  else
    exe docker start $@ $name
    startpost
  fi
}

run () {
  create
  start "$@"
}

startservice () {
  # Start the container's service via systemd
  exe systemctl start "$name"
}

stop () {
  # If the container is running, stop it
  isrunning $name && exe docker stop $name
}

stopservice () {
  # Stop the container's service via systemd
  exe systemctl stop "$name"
}

restart () {
  stop
  start
}

restartservice () {
  exe systemctl stop "$name"
  exe systemctl start "$name"
}

status () {
  # Print the status from docker and systemd
  echo -n "    Image: ";
  imagename=$(docker images -q $name)
  if [ -n "$imagename" ]; then
    echo -n "$imagename, created "
    timeago "`date -d ""$(docker inspect -f '{{.Created}}' $imagename)""`"
  else
    echo "(no such image)"
  fi
  echo -n "Container: "
  if containerexists $name; then
    echo -n "$name, created "
    timeago "`date -d ""$(docker inspect -f '{{.Created}}' $name)""`"
  else
    echo "(no such container)"
  fi
  echo -n "    State: "
  if isrunning $name; then
    echo -n -e "${GREEN}Running${NO_COLOR}, started "
    timeago "`date -d ""$(docker inspect -f '{{.State.StartedAt}}' $name)""`"
    exe docker ps | sed -e "1p" -e "/$name/!d"
  else
    echo "Inactive"
  fi
  if systemctl is-enabled $name 2>&1 >/dev/null; then
    echo "---------------------------------------------------------------------"
    exe systemctl status $name
  fi
}

journal () {
  # Print the systemd log entries for the service
  journalctl $@ -u "$name"
}

cmd () {
  exe docker exec -it $name $@
  exit $?
}

logs () {
  # Print the docker logs
  exe docker logs $@ $name
}

shell () {
  # Attach a shell to a running container
  exe docker exec -it $name /bin/sh
  return 0
}

runshell () {
  # Create a new version of the container with bash as the entry point
  # instead of what was specified in the Dockerfile
  remove
  #exe docker run -it $volumes $options --name $name $name /bin/sh
  exe docker run -it $volumes $options $(createnetwork) -h $name --name $name "$image" /bin/sh
  return 0
}

remove () {
  # Remove container if it exists
  containerexists $name && exe docker rm -f $name
}

removeimage () {
  # If the image exists, remove it
  [ "$(docker images -q $image 2>/dev/null)" == "" ] || \
    exe docker rmi -f $name
}

clean () {
  # Remove all references to the image and container
  remove
  removeimage
  [ -f "$build_dir/pipework" ] && exe rm "$build_dir/pipework"
}

firewall () {
  # Add firewall rules
  # TODO: Add iptables config
  :
}

install () {
  # Create systemd service file from template and register it
  while read line; do
    eval echo "$line"
  done <"$service_template" >/tmp/$name.service
  exe cp /tmp/$name.service /usr/lib/systemd/system/$name.service
  exe systemctl daemon-reload
  exe systemctl enable $name
}

uninstall () {
  # Uninstall the system service
  exe systemctl disable $name
  exe rm /usr/lib/systemd/system/$name.service
  exe systemctl daemon-reload
}

ps () {
  docker ps
}

cleanuntagged () {
  # Remove all untagged images
  exe docker rmi $(docker images | awk '/^<none>/ { print $3 }')
}

cleanall () {
  # Remove all docker images and containers
  exe docker rm `docker ps -aq`
  exe docker rmi `docker images -q`
}

isfn () {
  # Is $1 contained in $fns?
  for s in $fns; do
    [ "$1" == "$s" ] && return 0
  done
  return 1
}


### MAIN

[ "$1" == "help" ] && help

# This script needs to be run as root.
# If it's not run as root, then re-exec using sudo
[ "$(whoami)" == "root" ] || exec sudo -- "$0" "$@"

# Find the parameter file
if [ -d "$1" ]; then
  build_dir=`cd "$1" && pwd`
  build_file="DWfile"
  shift
elif [ -f "$1" ]; then
  build_dir=`cd "$( dirname ""$1"" )" && pwd`
  build_file="$(basename ""$1"")"
  shift
else
  build_dir=$(pwd)
  build_file="DWfile"
fi

# Read container specific parameters
. "$build_dir/$build_file"

# Use defaults if parameters are left blank
[ -z "$dw_dir" ] && dw_dir="/data/code/docker"
[ -z "$dw_template" ] && dw_template="$dw_dir/DWfile.template"
if [ -z "$service_template" ]; then
  if [ -f "$build_dir/$name.service" ]; then
    service_template="$build_dir/$name.service"
  else
    service_template="$dw_dir/template.service"
  fi
fi

# Set defaults
[ -z "$image" ] && image=$name
[ -z "$nettype" ] && nettype=bridge
# Guess the appropriate adapter name
[ -z "$adapter" ] && \
  adapter=$(ip -o link show | awk -F'[ :]+' '{if ($9 == "UP" && $2 ~ /^en/ ) { print $2 }}')
[ -z "$network" ] && network=bridge
[ -n "$subnet" ] && subnet_opts="--subnet $subnet"
[ -z "$*" ] && set -- start

# Make a list of the dw functions
fns=$(awk '/^[0-9a-zA-Z]+\s*\(\)/ {print $1}' $0 $build_dir/$build_file)

# Command line parameters are evaluated as functions if they are contained in
# this file or the DWfile. Otherwise, they are passed as arguments to the
# preceeding function
while [ -n "$*" ]; do
  cmd=$1
  shift
  params=
  while [ -n "$*" ] && ! isfn "$1"; do
    params+="$1 "
    shift
  done
  echo -e "$WHITE==> $CYAN$cmd$NO_COLOR $params"
  # $cmd $params
  if ! $cmd $params; then
    echo Aborting because a sub-command encountered an error
    exit 1
  fi
done
