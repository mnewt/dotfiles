#!/bin/sh

# Straightforward, zero dependency, portable distributed dotfile manager
# Run from a dotfile directory, links all files and directories into the current user's home directory

scriptname="$(basename $0)"
scriptbuildnum="0.10"
scriptbuilddate="2017-05-12"

### FUNCTIONS ###

NORMAL=000
RED=001
GREEN=002
YELLOW=003
BLUE=004
MAGENTA=005
CYAN=006
WHITE=007

with_color () {
  # background
  printf "\e[48;5;${1}m"
  # foreground
  printf "\e[38;5;${2}m"
  printf "${3}"
  # reset
  printf "\e[0m"
}

display_ver() {
  echo "$scriptname ver $scriptbuildnum - $scriptbuilddate"
}

display_help_text () {

  display_ver   # Print script-title, build-number, and build-date

  cat <<EOF

Links (or copies) files and directories from the current dir to the user's home dir

USAGE: $scriptname [OPTIONS] [SOURCE-DIR] [DEST-DIR]
    SOURCE-DIR defaults to the current directory
    DEST-DIR defaults to the current user's home directory

OPTIONS:
  -f (--force)    : force overwrite of files or directories in DEST-DIR
                    (default is false)
  -t (--test)     : test mode - only display changes, don't make them
                    (default is false)
  -c (--config)   : specify a configuration file
                    See the default configuration file (`install.settings`)
  -h (--help)     : display this help and exit
  -V (--version)  : output version information and exit

SOURCE-DIR        : directory containing dotfiles to be copied and/or linked
                    (default is current directory)
                      files should NOT have leading '.'
                      example: '.bashrc' should be named 'bashrc' in SOURCE-DIR
DEST-DIR          : target directory where copies and links will be placed
                    (default is '~')

EOF
}

list_contains() {
  for word in $1; do
    [ "$word" = "$2" ] && return 0
  done
  return 1
}

remove_dupes() {
  unset new_list
  for i in $1; do
    list_contains "$2" "$i" || new_list="$new_list $i"
  done
  echo "$new_list"
}

remove_file() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "rm -rf $1"
  elif [ "$force" = true ]; then
    with_color $NORMAL $RED "       REMOVING: "; echo "$1"
    rm -rf "$1"
  else
    with_color $NORMAL $BLUE "NOT OVERWRITING: "; echo "$1"
    return 1
  fi
}

link_file() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "ln -s $1 $2"
  else
    with_color $NORMAL $MAGENTA "        LINKING: "; echo "$2"
    ln -s "$1" "$2"
  fi
}

copy_file() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "cp -R $1 $2"
  else
    with_color $NORMAL $GREEN "        COPYING: "; echo "$2"
    cp -R "$1" "$2"
  fi
}

make_dir() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "mkdir -p $1"
  else
    with_color $NORMAL $CYAN "       CREATING: "; echo "$1"
    mkdir -p "$1"
  fi
}

### PRIMARY FUNCTIONS ###

make_links () {
  # Link each argument according to the global configuration
  for s in $1; do
    target="$dest_dir/.$s"
    src="$source_dir/$s"
    # if file (or a link) exists at destination
    if [ -e "$target" ] || [ -L "$target" ]; then
      remove_file "$target" && link_file "$src" "$target"
    else
      link_file "$src" "$target"
    fi
  done
}

make_copies () {
  # Copy each argument according to the global configuration
  for s in $1; do
    target="$dest_dir/.$s"
    src="$source_dir/$s"
    # if file (or a link) exists at destination
    if [ -e "$target" ] || [ -L "$target" ]; then
      remove_file "$target" && copy_file "$src" "$target"
    else
      copy_file "$src" "$target"
    fi
  done
}

link_children () {
  # `mkdir` each argument then run `make_links` on its children
  for s in $1; do
    target="$dest_dir/.$s"
    children=$(echo $s/*)
    [ -d "$target" ] && \
      with_color $NORMAL $YELLOW "   NOT REMOVING: "; echo "$target"
    if [ -e "$target" ] || [ -L "$target" ]; then
      make_dir "$target" && make_links "$children"
    else
      make_dir "$target" && make_links "$children"
    fi
  done
}

full_path () {
  echo "$(cd $1 && pwd)"
}

### PRE-EXECUTION TASKS ###

before () {
  :
}

after () {
  :
}

force=false
testing=false

config_file="$(full_path "$(dirname $0)")/install.settings"

# parse arguments
for arg in "$@"; do
  case "$arg" in
    -f|--force)
      force=true
      shift
      ;;
    -t|--testing)
      testing=true
      shift
      ;;
    -c|--config-file)
      shift
      config_file="$1"
      shift
      ;;
    -h|--help)
      display_help_text
      exit
      ;;
    -V|--version)
      display_ver
      exit
      ;;
  esac
done

### VARIABLE INITIALIZATION ###

# Read in settings
. "$config_file"

# Set default dirs (must occur after parameter parsing)
source_dir="${1:-$(pwd)}"
source_dir="$(full_path $source_dir)"
dest_dir="${2:-$HOME}"

echo Using settings:
with_color $NORMAL $CYAN "  config file:      $config_file\n"
with_color $NORMAL $CYAN "  source dir:       $source_dir\n"
with_color $NORMAL $CYAN "  destination dir:  $dest_dir\n"
echo

with_color $NORMAL $GREEN "        RUNNING: "; echo "before function"
before

### MAKE LISTS OF SOURCES ###

# Expand globs
link_sources=$(cd $source_dir && echo $link)
ignore_sources=$(cd $source_dir && echo $ignore)
copy_sources=$(cd $source_dir && echo $copy)
link_children_sources=$(cd $source_dir && echo $link_children)

# Remove duplicate and ignored files from file-lists
# For precedence rules, see `install.settings`
link_sources=$(remove_dupes "$link_sources" "$ignore_sources")
link_sources=$(remove_dupes "$link_sources" "$copy_sources")
link_sources=$(remove_dupes "$link_sources" "$link_children_sources")
copy_sources=$(remove_dupes "$copy_sources" "$ignore_sources")
link_children_sources=$(remove_dupes "$link_children_sources" "$ignore_sources")


### EXECUTE - MAKE LINKS, COPIES, AND DIRS ##

make_links "$link_sources"
make_copies "$copy_sources"
link_children "$link_children_sources"

with_color $NORMAL $GREEN "        RUNNING: "; echo 'after function'
after
