#!/usr/bin/env bash

shopt -s nullglob

scriptname="$(basename $0)"
scriptbuildnum="0.11"
scriptbuilddate="2018-05-23"

### FUNCTIONS ###

display_help_text () {
  cat <<EOF
$scriptname version $scriptbuildnum - $scriptbuilddate

Straightforward, zero dependency, portable  dotfile manager
Run from a dotfile repository directory, links all files and directories into the current user's home directory

USAGE: $scriptname [OPTIONS] [SOURCE-DIR] [DEST-DIR]
    SOURCE-DIR defaults to the current directory
    DEST-DIR defaults to the current user's home directory

OPTIONS:
  -f (--force)    : Force overwrite of files or directories in DEST-DIR
                    (default is false)
  -t (--test)     : Test mode - only display changes, don't make them
                    (default is false)
  -c (--config)   : Specify a configuration file
                    (see the default configuration file (install.settings))
  -h (--help)     : Display this help and exit
  -V (--version)  : Output version information and exit

SOURCE-DIR        : Directory containing dotfiles to be copied and/or linked
                    (default is current directory)
                      Files should NOT have leading '.'
                      example: '.bashrc' should be named 'bashrc' in SOURCE-DIR
DEST-DIR          : Target directory where copies and links will be placed
                    (default is '~')

EOF
}

NORMAL=000
RED=001
GREEN=002
YELLOW=003
BLUE=004
MAGENTA=005
CYAN=006
WHITE=007

# Canonicalize the path (does not necessarily expand symlinks)
full_path () {
  echo "$(cd $1 && pwd)"
}

# Print a string with ANSI X3.64 colors
# Color formats:
# * 8 color (30-37 for foreground and 40-37 for background), e.g. '31'
# * 256 color (000-255 -- must use 3 digits with leading zeros), e.g. '001'
# * 24 bit color, e.g. RGB: 255;255;255, or hex: FFFFFF
# * Anything else is processed as a raw ANSI escape sequence and passed directly to \e[<arg>m
# $1: background color
# $2: foreground color
# remaining args: string to print
with_color () {
  local bg="$1"
  local fg="$2"
  shift 2

  case ${#bg} in
    3)   bg="48;5;$bg"
         fg="38;5;$fg"
         ;;
    6)   bg="$(printf "48;2;%d;%d;%d" "0x${bg:0:2}" "0x${bg:2:2}" "0x${bg:4:2}")"
         fg="$(printf "38;2;%d;%d;%d" "0x${fg:0:2}" "0x${fg:2:2}" "0x${fg:4:2}")"
         ;;
    11)  bg="$(printf "48;2;%d;%d;%d" ${bg:0:3} ${bg:4:3} ${bg:9:3})"
         fg="$(printf "48;2;%d;%d;%d" ${fg:0:3} ${fg:4:3} ${fg:9:3})"
  esac

  printf "\033[${bg}m\033[${fg}m%s\033[0m" "$@"
}

# Return true iff $1 is an exact match for any subsequent argument
list_contains() {
  match="$1"
  shift
  for j in "$@"; do
    [ "$j" = "$match" ] && return 0
  done
  return 1
}

# Remove items from array $1 that are matches for items in array $2.
# Both $1 and $2 are names of global variables.
# The variable referenced by $1 is modified in place.
remove_matches() {
  original_ref=$1[@]
  original=("${!original_ref}")
  matches_ref=$2[@]
  matches=("${!matches_ref}")
  new=()
  for i in "${original[@]}"; do
    list_contains "$i" "${matches[@]}" || new+=("$i")
  done
  eval $1=\("\${new[@]}"\)
}

# If a file or link exists at $1, remove it.
# If it's a directory, don't remove it.
remove_file() {
  if [ -L "$1" ] || [ -f "$" ]; then
    if [ "$testing" = true ]; then
      with_color $NORMAL $YELLOW "        TESTING: "; echo "rm -f $1"
    elif [ "$force" = true ]; then
      with_color $NORMAL $RED "       REMOVING: "; echo "$1"
      rm -f "$1"
    else
      with_color $NORMAL $BLUE "NOT OVERWRITING: "; echo "$1"
      return 1
    fi
  elif [ -d "$1" ]; then
    with_color $NORMAL $BLUE "NOT REMOVING DIR "
    echo "$target"
    return 1
  fi
}

# Create a soft link from $1 to $2
link_file() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "ln -s $1 $2"
  else
    with_color $NORMAL $MAGENTA "        LINKING: "; echo "$2"
    ln -s "$1" "$2"
  fi
}

# Copy a file from $1 to $2
copy_file() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "cp -R $1 $2"
  else
    with_color $NORMAL $GREEN "        COPYING: "; echo "$2"
    cp -R "$1" "$2"
  fi
}

# Create a directory at $1 if it doesn't already exist
make_dir() {
  if [ "$testing" = true ]; then
    with_color $NORMAL $YELLOW "        TESTING: "; echo "mkdir -p $1"
  else
    if [ -e "$1" ]; then
      with_color $NORMAL $BLUE   "   NOT CREATING: "; echo "$1"
    else
      with_color $NORMAL $CYAN   "       CREATING: "; echo "$1"
      mkdir -p "$1"
    fi
  fi
}

### PRIMARY FUNCTIONS ###

# Link each argument according to the global configuration
# $1: The literal prefix. Can include directory name and file prefix, such as '$HOME/.'
# each remaining element is the suffix, so it would end up '$HOME/.filename'
make_links () {
  prefix="$1"
  shift
  for s in "$@"; do
    target="$prefix$s"
    src="$source_dir/$s"
    remove_file "$target" && link_file "$src" "$target"
  done
}

# Copy each argument according to the global configuration
# $1: The literal prefix. Can include directory name and file prefix, such as '$HOME/.'
# each remaining element is the suffix, so it would end up '$HOME/.filename'
make_copies () {
  prefix="$1"
  shift
  for s in "$@"; do
    target="$prefix$s"
    src="$source_dir/$s"
    remove_file "$target" && copy_file "$src" "$target"
  done
}

# `mkdir` each argument then run `make_links` on its children
# $1: The literal prefix. Can include directory name and file prefix, such as '$HOME/.'
# each remaining element is the suffix, so it would end up '$HOME/.filename'
link_children () {
  prefix="$1"
  shift
  for s in "$@"; do
    target="$prefix$s"
    children=($(cd $source_dir && echo $s/*))
    remove_file "$target" && make_dir "$target"
    make_links "$prefix" "${children[@]}"
  done
}

### PRE-EXECUTION TASKS ###

before () {
  :
}

after () {
  :
}

force=false
testing=false

config_file="$(full_path "$(dirname $0)")/install.settings"

# parse arguments
for arg in "$@"; do
  case "$arg" in
    -f|--force)
      force=true
      shift
      ;;
    -t|--testing)
      testing=true
      shift
      ;;
    -c|--config-file)
      shift
      config_file="$1"
      shift
      ;;
    -h|--help)
      display_help_text
      exit
      ;;
    -V|--version)
      display_ver
      exit
      ;;
  esac
done

### VARIABLE INITIALIZATION ###

# Read in settings
. "$config_file"

# Set default dirs (must occur after parameter parsing)
source_dir="${1:-$(pwd)}"
source_dir="$(full_path $source_dir)"
dest_dir="${2:-$HOME}"

echo "Installing dotfiles using settings:"
with_color $NORMAL $CYAN "  config file:      $config_file"
echo
with_color $NORMAL $CYAN "  source dir:       $source_dir"
echo
with_color $NORMAL $CYAN "  destination dir:  $dest_dir"
echo
echo

with_color $NORMAL $GREEN "        RUNNING: "; echo "before function"
before

### PREPARE LISTS OF SOURCES ###

cd "$source_dir"

# Remove duplicate and ignored files from file-lists.
# For precedence rules, see `install.settings`.
remove_matches link ignore
remove_matches link copy
remove_matches link link_children
remove_matches copy ignore
remove_matches link_children ignore

### EXECUTE - MAKE LINKS, COPIES, AND DIRS ##

make_links "$dest_dir/." "${link[@]}"
make_copies "$dest_dir/." "${copy[@]}"
link_children "$dest_dir/." "${link_children[@]}"

with_color $NORMAL $GREEN "        RUNNING: "; echo 'after function'
after
